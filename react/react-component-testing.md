Why Testing Frontend Makes Sense

We test apps regularly to ensure everything works as it should, finding any bugs before users do.

Manual tests are unreliable and time consuming. We can instead use automated component tests to simulate interactions.

This approach interacts with the app the way that a user might, searching in the rendered app for certain elements:

    Search for a heading with certain content
    Search input fields with certain labels and insert text
    Search for a button with a certain label and click to submit a form
    Search for an expected result that should be displayed after submit

We write these tests for each React component in our code.

In a previous session we looked at unit testing, which tests a single unit/function. Component tests are integration tests, which test how various individual units/functions work together, and are displayed on a user's screen.

Testing a full app, or complete page would be End-to-End testing, which comes later in the process. We instead want to first create separate smaller tests for individual components. 

As with unit tests these are placed in a separate test file next to the component file, with the suffix .test.js

Testing Library

A testing library lets us render React components in jest tests, simulating user behaviour and checking the results once the component has been rerendered.

For Example

import { useState } from "react";

export default function FahrenheitConverter() {
  const [fahrenheit, setFahrenheit] = useState();

  function handleSubmit(event) {
    event.preventDefault();

    const form = event.target;
    const formElements = form.elements;
    const celsius = formElements.celsius.value;

    setFahrenheit((celsius * 9) / 5 + 32);
  }

  return (
    <div>
      <h1>Temperature Unit Converter</h1>
      <form onSubmit={handleSubmit}>
        <label htmlFor="celsius">째C</label>
        <input type="number" id="celsius" name="celsius" />
        <button>Convert to Fahrenheit</button>
      </form>
      {fahrenheit ? (
        <output>{fahrenheit} 째F</output>
      ) : (
        <p>Please enter a Celsius value and submit</p>
      )}
    </div>
  );
}

This is a FahrenheitConverter component, which renders a heading, a form and a result output. If it has not been submitted, a fallback message is displayed instead of the result. Once the form has been submitted, the calculation is made, and the result is saved to state. This will trigger a re-rendering of the component, so that a result will be displayed.

There are three tests that we want to run for this:
    That the heading displays
    That the fallback message displays
    That the form interaction and submit works, resulting in the correct result.

import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import FahrenheitConverter from ".";

test("renders a heading", () => {
  render(<TemperatureUnitConverter />);
  const heading = screen.getByRole("heading", {
    name: /temperature unit converter/i,
  });
  expect(heading).toBeInTheDocument();
});

test("renders a fallback message if form is not yet submitted", () => {
  render(<FahrenheitConverter />);
  const message = screen.getByText(/please enter a celsius value and submit/i);
  expect(message).toBeInTheDocument();
});

test("converts Celsius to Fahrenheit and renders the result", async () => {
  const user = userEvent.setup();

  render(<FahrenheitConverter />);

  const input = screen.getByLabelText(/째C/i);
  expect(input).toBeInTheDocument();

  const button = screen.getByRole("button", { name: /convert to fahrenheit/i });
  expect(button).toBeInTheDocument();

  await user.type(input, "5");
  await user.click(button);

  const output = screen.getByText(/41 째F/i);
  expect(output).toBeInTheDocument();

  const message = screen.queryByText(
    /please enter a celsius value and submit/i
  );
  expect(message).not.toBeInTheDocument();
});

Rendering a Component

With render you can render the FahrenheitConverter component. Then you can use screen to access the html generated by the component.

Using Queries

With screen you can use queries to search for an expected element in the HTML.

    ByRole - Search for an element based on their role/aria attribute
    ByLabelText - Search for an element with a given label
    ByText - Search for a given text
    ByTestId - Last resort. Search for a element you are unable to address with other queries. Mark the element with the attribute data-testid

Typically we use queries with getBy when we want the test to fail if the element is not found.

In cases where we want to test is something is NOT displayed, we can use queryBy, which won't fail the test, but will return null.

You can define a test with a string: getByText("Text Here")

You can also place the text in / slashes followed by i instead of using double quotes.

/ /i is more resilient to changes in the implementation (for instance if the component changed casing) The expression enclosed in slashes is called the "regular expression" and the i tells us to ignore the case.

Simulate User Events

You can simulate a user with userEvent.setup() You can then simulate events like type or click. Remember to use await, as these are asynchronous.

Using Matchers

Using expect you can use matchers to formulate a result for your test, as in unit testing.

Since HTML components are being generated, toBeInTheDocument is used very commonly.

Mocks

A mock is a substitute that is used in the test in place of the original function. These include:

    Event-handler functions passed as a prop to a component
    Replacing an imported package

Mocks reduce the number of dependencies in a test and provide a testable environment for the component.

Mock Function for Event-Handlers

Consider a Counter component that accepts two event-handler functions as prop (properties)

export default function Counter({ onDecrease, onIncrease }) {
  return (
    <>
      <button type="button" onClick={onDecrease}>
        decrease
      </button>
      <button type="button" onClick={onIncrease}>
        increase
      </button>
    </>
  );
}



